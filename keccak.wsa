include memory
include bitwise

; https://keccak.team/keccak_specs_summary.html
; SHA3-256: r=1088 c=512, output length = 256, Mbits=01, d=0x06, b=1600, w=64, rounds=24
; https://emn178.github.io/online-tools/keccak_256.html
; https://github.com/mjosaarinen/tiny_sha3/blob/master/sha3.c
; https://github.com/emn178/js-sha3/blob/master/src/sha3.js

jump keccak_lib_end

; returns &keccak
label keccak_init
  ; [RC[24], r[x=5,y=5]]
  push 49
  call malloc
  ; Fill RC[24]
  push 0x0000000000000001
  push 0x0000000000008082
  push 0x800000000000808A
  push 0x8000000080008000
  push 0x000000000000808B
  push 0x0000000080000001
  push 0x8000000080008081
  push 0x8000000000008009
  push 0x000000000000008A
  push 0x0000000000000088
  ; 10
  push 0x0000000080008009
  push 0x000000008000000A
  push 0x000000008000808B
  push 0x800000000000008B
  push 0x8000000000008089
  push 0x8000000000008003
  push 0x8000000000008002
  push 0x8000000000000080
  push 0x000000000000800A
  push 0x800000008000000A
  ; 20
  push 0x8000000080008081
  push 0x8000000000008080
  push 0x0000000080000001
  push 0x8000000080008008
  copy 24
  push 24
  call keccak_store_n

  ; Fill r[x=5,y=5]
  ; x=0
  push 0
  push 36
  push 3
  push 41
  push 18
  ; x=1
  push 1
  push 44
  push 10
  push 45
  push 2
  ; x=2
  push 62
  push 6
  push 43
  push 15
  push 61
  ; x=3
  push 28
  push 55
  push 25
  push 21
  push 56
  ; x=4
  push 27
  push 20
  push 39
  push 8
  push 14
  copy 25
  add 24
  push 25
  call keccak_store_n
ret

; args .., addr, n
label keccak_store_n
  swap
  push 1
  call stack_freeze
  label keccak_store_n_loop
    dup
    jumpz keccak_store_n_end
    sub 1
    dup
    call stack_get_head
    add
    copy 2
    store
    swap
    pop
  jump keccak_store_n_loop
  label keccak_store_n_end
  pop
  push 1
  call stack_discard
ret

; args &A, RC
label keccak_round
  swap
  push 1
  call stack_freeze
  push 4
  ; [&A] [RC, x]
  label keccak_round_c
    dup
    jumpn keccak_round_c_end
    dup
    mul 5
    call stack_get_head
    add
    ; [RC, x, &A[x,0]]
    dup
    retrieve
    swap
    add 1
    swap
    ; [RC, x, &A[x,1], A[x,0]]
    copy 1
    retrieve
    call bitwise_xor
    swap
    add 1
    swap
    ; [RC, x, &A[x,2], C[wip]]
    copy 1
    retrieve
    call bitwise_xor
    swap
    add 1
    swap
    ; [RC, x, &A[x,3], C[wip]]
    copy 1
    retrieve
    call bitwise_xor
    swap
    add 1
    swap
    ; [RC, x, &A[x,4], C[wip]]
    swap
    retrieve
    call bitwise_xor
    ; [RC, x, C[x]]
    swap
    sub 1
  jump keccak_round_c
  label keccak_round_c_end
  pop
  ; [&A] [RC, C[4..0]]

  push 5
  call stack_freeze
  push 4
  ; [&A, C[4..0]] [RC, x]
  label keccak_round_d
    dup
    jumpn keccak_round_d_end
    dup
    add 1
    mod 5
    push 0
    swap
    sub
    call stack_get
    push 1
    push 64
    call bitwise_rotl
    push 5
    copy 2
    sub 1
    call __keccak_circle
    push 0
    swap
    sub
    call stack_get
    call bitwise_xor
    swap
    sub 1
  jump keccak_round_d
  label keccak_round_d_end
  pop
  ; [&A, C[4..0]] [RC, D[4..0]]

  push 5
  call stack_discard
  push 5
  call stack_freeze
  push 24
  ; [&A, D[4..0]] [RC, {x,y}]
  label keccak_round_theta
    dup
    jumpn keccak_round_theta_end
    dup
    push -5
    call stack_get
    add
    ; [RC, {x,y}, &A[x,y]]
    dup
    retrieve
    copy 2
    div 5
    push 0
    swap
    sub
    call stack_get
    call bitwise_xor
    ; [RC, {x,y}, &A[x,y], A[x,y]^D[x]]
    store
    sub 1
  jump keccak_round_theta
  label keccak_round_theta_end

  
ret

; args m, n
; returns n % m, with guaranteed positive result
label __keccak_circle
  dup
  jumppz __keccak_circle_positive
  copy 1
  add
  jump __keccak_circle
  label __keccak_circle_positive
  swap
  mod
ret


label keccak_lib_end

call keccak_init
