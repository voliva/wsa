include memory
include bitwise

; https://keccak.team/keccak_specs_summary.html
; SHA3-256: r=1088 c=512, output length = 256, Mbits=01, d=0x06, b=1600, w=64, rounds=24
; https://emn178.github.io/online-tools/keccak_256.html
; https://github.com/mjosaarinen/tiny_sha3/blob/master/sha3.c
; https://github.com/emn178/js-sha3/blob/master/src/sha3.js

jump keccak_lib_end

; returns &keccak
label keccak_init
  ; [RC[24], r[x=5,y=5]]
  push 49
  call malloc
  ; Fill RC[24]
  push 0x0000000000000001
  push 0x0000000000008082
  push 0x800000000000808A
  push 0x8000000080008000
  push 0x000000000000808B
  push 0x0000000080000001
  push 0x8000000080008081
  push 0x8000000000008009
  push 0x000000000000008A
  push 0x0000000000000088
  ; 10
  push 0x0000000080008009
  push 0x000000008000000A
  push 0x000000008000808B
  push 0x800000000000008B
  push 0x8000000000008089
  push 0x8000000000008003
  push 0x8000000000008002
  push 0x8000000000000080
  push 0x000000000000800A
  push 0x800000008000000A
  ; 20
  push 0x8000000080008081
  push 0x8000000000008080
  push 0x0000000080000001
  push 0x8000000080008008
  copy 24
  push 24
  call keccak_store_n

  ; Fill r[x=5,y=5]
  ; x=0
  push 0
  push 36
  push 3
  push 41
  push 18
  ; x=1
  push 1
  push 44
  push 10
  push 45
  push 2
  ; x=2
  push 62
  push 6
  push 43
  push 15
  push 61
  ; x=3
  push 28
  push 55
  push 25
  push 21
  push 56
  ; x=4
  push 27
  push 20
  push 39
  push 8
  push 14
  copy 25
  add 24
  push 25
  call keccak_store_n
ret

; args .., addr, n
label keccak_store_n
  swap
  push 1
  call stack_freeze
  label keccak_store_n_loop
    dup
    jumpz keccak_store_n_end
    sub 1
    dup
    call stack_get_head
    add
    copy 2
    store
    swap
    pop
  jump keccak_store_n_loop
  label keccak_store_n_end
  pop
  push 1
  call stack_discard
ret

; args RC, &r, &A
label keccak_round
  push 2
  call stack_freeze
  push 4
  ; [&r, &A] [RC, x]
  label keccak_round_c
    dup
    jumpn keccak_round_c_end
    dup
    mul 5
    call stack_get_head
    add
    ; [RC, x, &A[x,0]]
    dup
    retrieve
    swap
    add 1
    swap
    ; [RC, x, &A[x,1], A[x,0]]
    copy 1
    retrieve
    call bitwise_xor
    swap
    add 1
    swap
    ; [RC, x, &A[x,2], C[wip]]
    copy 1
    retrieve
    call bitwise_xor
    swap
    add 1
    swap
    ; [RC, x, &A[x,3], C[wip]]
    copy 1
    retrieve
    call bitwise_xor
    swap
    add 1
    swap
    ; [RC, x, &A[x,4], C[wip]]
    swap
    retrieve
    call bitwise_xor
    ; [RC, x, C[x]]
    swap
    sub 1
  jump keccak_round_c
  label keccak_round_c_end
  pop
  ; [&r, &A] [RC, C[4..0]]

  push 5
  call stack_freeze
  push 4
  ; [&r, &A, C[4..0]] [RC, x]
  label keccak_round_d
    dup
    jumpn keccak_round_d_end
    dup
    add 1
    mod 5
    push 0
    swap
    sub
    call stack_get
    push 1
    push 64
    call bitwise_rotl
    push 5
    copy 2
    sub 1
    call __keccak_circle
    push 0
    swap
    sub
    call stack_get
    call bitwise_xor
    swap
    sub 1
  jump keccak_round_d
  label keccak_round_d_end
  pop
  ; [&r, &A, C[4..0]] [RC, D[4..0]]

  push 5
  call stack_discard
  push 5
  call stack_freeze
  push 24
  ; [&r, &A, D[4..0]] [RC, {x,y}]
  label keccak_round_theta
    dup
    jumpn keccak_round_theta_end
    dup
    push -5
    call stack_get
    add
    ; [RC, {x,y}, &A[x,y]]
    dup
    retrieve
    copy 2
    div 5
    push 0
    swap
    sub
    call stack_get
    call bitwise_xor
    ; [RC, {x,y}, &A[x,y], A[x,y]^D[x]]
    store
    sub 1
  jump keccak_round_theta
  label keccak_round_theta_end
  pop

  push 5
  call stack_discard
  push 25
  call stack_reserve
  push 4
  ; [&r, &A, B[24..0]] [RC, x]
  label keccak_round_rp_x
    dup
    jumpn keccak_round_rp_x_end
    push 4
    ; [&r, &A, B[24..0]] [RC, x, y]
    label keccak_round_rp_y
      dup
      jumpn keccak_round_rp_y_end
      copy 1
      mul 5
      copy 1
      add
      ; [&r, &A, B[24..0]] [RC, x, y, {x,y}]
      dup
      push -25
      call stack_get
      add
      retrieve
      swap
      push -26
      call stack_get
      add
      retrieve
      push 64
      call bitwise_rotl
      ; [&r, &A, B[24..0]] [RC, x, y, B[y,2*x+3*y]]
      copy 2
      mul 2
      copy 2
      mul 3
      add
      mod 5
      copy 2
      mul 5
      add
      push 0
      swap
      sub
      swap
      call stack_set
      ; [&r, &A, B[24..0]] [RC, x, y]
      sub 1
    jump keccak_round_rp_y
    label keccak_round_rp_y_end
    pop
    sub 1
  jump keccak_round_rp_x
  label keccak_round_rp_x_end
  pop

  push 24
  ; [&r, &A, B[24..0]] [RC, {x,y}]
  label keccak_round_x
    dup
    jumpn keccak_round_x_end
    dup
    add 5
    mod 25
    push 0
    swap
    sub
    call stack_get
    ; [&r, &A, B[24..0]] [RC, {x,y}, B[x+1,y]]
    push 64
    call bitwise_not
    copy 1
    add 10
    mod 25
    push 0
    swap
    sub
    call stack_get
    ; [&r, &A, B[24..0]] [RC, {x,y}, ~B[x+1,y], B[x+2,y]]
    call bitwise_and
    copy 1
    push 0
    swap
    sub
    call stack_get
    call bitwise_xor
    copy 1
    push -25
    call stack_get
    add
    swap
    store
    sub 1
    jump keccak_round_x
  label keccak_round_x_end
  pop
  push 25
  call stack_discard

  ; [&r, &A] [RC]
  ; iota step
  call stack_get_head
  retrieve
  call bitwise_xor
  call stack_get_head
  swap
  store

  push 2
  call stack_discard
ret

; args &keccak, &A
label keccak_f
  push 0
  label keccak_f_loop
    dup
    sub 24
    jumpz keccak_f_loop_end
    ; [&keccak, &A, i]
    dup
    copy 3
    add
    copy 3
    add 24
    copy 3
    call keccak_round
    add 1
  jump keccak_f_loop
  label keccak_f_loop_end
ret

; args &MBytes, len
label keccak_padding
; Assuming block size of r/w = 17
  dup
  copy 2
  add
  push 0x06
  store
  add 1
  dup
  mod 17
  jumpz keccak_padding_xor
  ; dest
  dup
  copy 2
  add
  ; value
  push 0
  ; size
  copy 2
  mod 17
  push 17
  swap
  sub
  call memset
  div 17
  add 1
  mul 17
  label keccak_padding_xor
  ; xor the last position with 0x80
  sub 1
  add
  dup
  retrieve
  push 0x80
  call bitwise_xor
  store
ret

; args m, n
; returns n % m, with guaranteed positive result
label __keccak_circle
  dup
  jumppz __keccak_circle_positive
  copy 1
  add
  jump __keccak_circle
  label __keccak_circle_positive
  swap
  mod
ret

label keccak_lib_end

call keccak_init
push 25
call malloc
push 24
label fill_input
  dup
  jumpn fill_input_end
  dup
  copy 2
  add
  copy 1
  store
  sub 1
  jump fill_input
label fill_input_end
pop

copy 1
retrieve
copy 2
add 24
copy 2
call keccak_round
