valueinteger _STACK_HEAD 0
valueinteger _HEAP_HEAD 4294967294

label memory_init
push 0
doub
store _STACK_HEAD
store _HEAP_HEAD
ret

; arg: size
; Returns address of new block
label malloc
push 1
call stack_freeze

retrive _HEAP_HEAD
doub
jumpz malloc_empty

; find an entry in-between two blocks where I can fit
; preparing an invariant stack of [&head,&prev]. _HEAP_HEAD is &prev
push _HEAP_HEAD

label malloc_find_empty
; we need to check `&head+head.size+2 + size+2 < &prev`
; then store in `&head+head.size+2`, and update &prev.next
; get &head
scpy 1
; get head.size
doub
add 1
retrive
; &head + head.size
add
add 2
; save `&head+head.size+2` for later
doub
call stack_get_head
add
add 2
; we have 2 extra elements in the stack. Get &prev
scpy 2
sub
jumpnz malloc_in_between
; the spot is not lare enough, remove the `&head+head.size+2`
pop
; remove &prev
pop
; get next head
doub
retrive
doub
jumpz malloc_end_chain
; satisfy invariant [&head,&prev]: Previous head is now prev
swap
jump malloc_find_empty
label malloc_end_chain
; head.next was pointing to 0, get the state ready to call malloc_allocate
; TODO maybe malloc_empty can be reused?
; remove the 0 (head.next)
pop
; head = &head - `size` - 2
doub
call stack_get_head
sub
sub 2
doub
; size = `size`
call stack_get_head
; prev = &head
scpy 3
; next = 0
push 0
; Perform call
call malloc_allocate
slide 2
jump malloc_end

label malloc_in_between
; stack: [&head,&prev,&new_head]
; goal: [&new_head,size,&prev,&head] = head,size,prev,next
swap
call stack_get_head
swap
scpy 3
; Perform call
call malloc_allocate
slide 1
jump malloc_end

label malloc_empty
pop

; head = _HEAP_HEAD - `size` - 2
push _HEAP_HEAD
call stack_get_head
sub
sub 2
doub
; size = `size`
call stack_get_head
; prev = _HEAP_HEAD
push _HEAP_HEAD
; next = 0
push 0
; Perform call
call malloc_allocate
pop
; In stack we have the head of the element, because of the doub performed after calculating it

label malloc_end
; Assuming we have addr of head on stack
add 2

push 1
call stack_discard
ret

; arg: head, size, prev, next
; Returns head
label malloc_allocate
; Store `next` to &`head`
scpy 3
swap
store
; Stack [head, size, prev]
; Store &`head` to &`prev`
scpy 2
store
; Stack [head, size]
; Store `size` to &`head`+1
scpy 1
add 1
swap
store
; Return &head
ret

; args: data_pointer
; Returns boolean, whether it has been freed or not
label mfree
; Load [&target, &initial_prev]
sub 2
doub
push _HEAP_HEAD
call memory_find_prev
; As a result we have [.. &prev]
; if it's 0 we've reached the end without finding it
doub
jumppn mfree_found
pop
pop
; return false as result
push 0
ret
label mfree_found
; set prev.next to data_pointer.next
swap
retrive
store
push 1
ret

; args: source, dest, size
label memcpy
; invariant [&end_dest,&dest,&source]
scpy 1
add
swap
scpy 2

label memcpy_copy_next
scpy 2
scpy 2
sub
jumpz memcpy_end
doub
retrive
scpy 2
swap
store

add 1
swap
add 1
swap
jump memcpy_copy_next

label memcpy_end
pop
pop
pop
pop

ret

; args: dest, value, size
label memset
; invariant [value,&end_dest,&dest]
scpy 2
add
scpy 2
label memset_set_next
doub
scpy 2
sub
jumpz memset_end
doub
scpy 3
store
add 1
jump memset_set_next

label memset_end
pop
pop
pop
pop

ret

; args: data_pointer, size
; returns new address
label realloc
push 2
call stack_freeze
; calculate end memory in current location
push -1
call stack_get
call stack_get_head
add
; Load [.. &target, &initial_prev]
push -1
call stack_get
sub 2
push _HEAP_HEAD
call memory_find_prev
; As a result we have [.. &prev]
sub
; &prev must be > end memory to be able to resize in place
jumpn realloc_resize
; malloc -> memcpy -> mfree
call stack_get_head
call malloc
; On stack now we have [&dest]
; We have to keep the new address to return it at the end
doub
; prepare stack [&source &dest size]
push -1
call stack_get
swap
call stack_get_head
call memcpy
push -1
call stack_get
call mfree
jump realloc_end
label realloc_resize
push -1
call stack_get
sub 1
call stack_get_head
store
label realloc_end
push 2
call stack_discard
ret

; Invariant stack: [&target, &prev]
; Will result in stack: [&prev]
label memory_find_prev
doub
retrive
; if it's 0 we've reached the end without finding it
doub
jumppn memory_find_check
pop
pop
pop
pop
; return 0 as result
push 0
ret
label memory_find_check
scpy 2
sub
jumpz memory_found
retrive
jump memory_find_prev
label memory_found
; set prev.next to data_pointer.next
swap
pop
ret

; args: length
label stack_freeze
doub
retrive _STACK_HEAD
add
doub
store _STACK_HEAD
swap
; [a,b,c,d,H,L]
label stack_freeze_loop
doub
jumpz stack_freeze_end
sub 1
; I can't slide keeping 2 values, which are important on the loop
; I will store that into +1, because we already updated the _STACK_HEAD it should be alright
push 1
swap
call stack_set
doub
scpy 2
store
slide 1
sub 1
push 1
call stack_get
jump stack_freeze_loop
label stack_freeze_end
pop
pop
ret

; args: length
label stack_restore
; store length on +1
doub
push 1
swap
call stack_set
sub 1
label stack_restore_loop
doub
retrive _STACK_HEAD
swap
sub
retrive
swap
sub 1
doub
jumppz stack_restore_loop
pop
retrive _STACK_HEAD
doub
add 1
retrive
sub
store _STACK_HEAD
ret

; args: length
label stack_discard
retrive _STACK_HEAD
swap
sub
store _STACK_HEAD
ret

; args: offset
label stack_get
retrive _STACK_HEAD
add
retrive
ret

; args: offset value
label stack_set
swap
retrive _STACK_HEAD
add
swap
store
ret

label stack_get_head
retrive _STACK_HEAD
retrive
ret