valueinteger _STACK_HEAD 0
valueinteger _HEAP_HEAD 4294967294

label memory_init
push 0
doub
store _STACK_HEAD
store _HEAP_HEAD
ret

; arg: size
label malloc
retrive _HEAP_HEAD
doub
jumpz malloc_empty

; find an entry in-between two blocks where I can fit
; preparing an invariant stack of [&head,&prev]. _HEAP_HEAD is &prev
push _HEAP_HEAD

label malloc_find_empty
; we need to check `&head+head.size+2 + size+2 < &prev`
; then store in `&head+head.size+2`, and update &prev.next
; get &head
scpy 1
; get head.size
doub
add 1
retrive
; &head + head.size
add
add 2
; save `&head+head.size+2` for later
doub
retrive -0
add
add 2
; we have 2 extra elements in the stack. Get &prev
scpy 2
sub
jumpnz malloc_in_between
; the spot is not lare enough, remove the `&head+head.size+2`
pop
; remove &prev
pop
; get next head
doub
retrive
doub
jumpz malloc_end_chain
; satisfy invariant [&head,&prev]: Previous head is now prev
swap
jump malloc_find_empty
label malloc_end_chain
; head.next was pointing to 0, get the state ready to call malloc_allocate
; TODO maybe malloc_empty can be reused?
; remove the 0 (head.next)
pop
; head = &head - `size` - 2
doub
retrive -0
sub
sub 2
store +1
; size = `size`
retrive -0
store +2
; prev = &head
store +3
; next = 0
push 0
store +4
; Perform call
retrive _STACK_HEAD
add 4
store _STACK_HEAD
call malloc_allocate
jump malloc_end

label malloc_in_between
; stack: [&head,&prev,&new_head]
; head = &new_head
store +1
; size = `size`
retrive -0
store +2
; prev = &prev
store +3
; next = &head
store +4
; Perform call
retrive _STACK_HEAD
add 4
store _STACK_HEAD
call malloc_allocate
jump malloc_end

jump malloc_end

label malloc_empty
pop

; head = _HEAP_HEAD - `size` - 2
push _HEAP_HEAD
retrive -0
sub
sub 2
doub
store +1
; size = `size`
retrive -0
store +2
; prev = _HEAP_HEAD
push _HEAP_HEAD
store +3
; next = 0
push 0
store +4
; Perform call
retrive _STACK_HEAD
add 4
store _STACK_HEAD
call malloc_allocate
pop
; In stack we have the head of the element, because of the doub performed after calculating it

label malloc_end
; Assuming we have addr of head on stack
add 2

retrive _STACK_HEAD
sub 1
store _STACK_HEAD
ret

; arg: head, size, prev, next
label malloc_allocate
; Store `next` to &`head`
retrive -3
retrive -0
store
; Store `size` to &`head`+1
retrive -3
add 1
retrive -2
store
; Store &`head` to &`prev`
retrive -1
retrive -3
store
; Return &head
retrive -3

retrive _STACK_HEAD
sub 4
store _STACK_HEAD
ret

; args: data_pointer
label mfree
; Load [&target, &initial_prev]
retrive -0
sub 2
push _HEAP_HEAD
call memory_find_prev
; As a result we have [&prev]
; if it's 0 we've reached the end without finding it
doub
jumppn mfree_found
pop
; return false as result
push 0
jump mfree_end
label mfree_found
; set prev.next to data_pointer.next
retrive -0
sub 2
retrive
store
push 1

label mfree_end
retrive _STACK_HEAD
sub 1
store _STACK_HEAD
ret

; args: source, dest, size
label memcpy
; invariant [&end_dest,&dest,&source]
retrive -1
doub
retrive -0
add
swap
retrive -2

label memcpy_copy_next
scpy 2
scpy 2
sub
jumpz memcpy_end
doub
retrive
scpy 2
swap
store

add 1
swap
add 1
swap

jump memcpy_copy_next

label memcpy_end
pop
pop
pop

push 0
retrive _STACK_HEAD
sub 3
store _STACK_HEAD
ret

; args: dest, value, size
label memset
; invariant [value,&end_dest,&dest]
retrive -1
retrive -2
doub
retrive -0
add
swap
label memset_set_next
doub
scpy 2
sub
jumpz memset_end
doub
scpy 3
store
add 1
jump memset_set_next

label memset_end
pop
pop
pop

push 0
retrive _STACK_HEAD
sub 3
store _STACK_HEAD
ret

; args: data_pointer, size
label realloc
; calculate end memory in current location
retrive -1
retrive -0
add
; Load [.. &target, &initial_prev]
retrive -1
sub 2
push _HEAP_HEAD
call memory_find_prev
; As a result we have [.. &prev]
sub
; &prev must be > end memory to be able to resize in place
jumpn realloc_resize
; malloc -> memcpy -> mfree
retrive -0
store +1
retrive _STACK_HEAD
add 1
store _STACK_HEAD
call malloc
; We have to keep the new address to return it at the end
doub
; prepare virtual stack [&source &dest size]
store +2
retrive -1
store +1
retrive -0
store +3
retrive _STACK_HEAD
add 3
store _STACK_HEAD
call memcpy
pop
retrive -1
store +1
retrive _STACK_HEAD
add 1
store _STACK_HEAD
call mfree
ret
label realloc_resize
retrive -1
sub 1
retrive -0
store
push 0
ret

; Invariant stack: [&target, &prev]
; Will result in stack: [&prev]
label memory_find_prev
doub
retrive
; if it's 0 we've reached the end without finding it
doub
jumppn memory_find_check
pop
pop
pop
pop
; return 0 as result
push 0
ret
label memory_find_check
scpy 2
sub
jumpz memory_found
retrive
jump memory_find_prev
label memory_found
; set prev.next to data_pointer.next
swap
pop
ret
