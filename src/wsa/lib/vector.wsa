include memory

jump lib_vector_end

; args capacity
; returns &V
label vector_new
  ; Vec = [&data,cap,len]
  push 3
  call malloc
  swap
  ; [&V, cap]
  dup
  call malloc
  ; [&V, cap, &data]
  copy 2
  swap
  store
  ; [&V, cap]
  copy 1
  add 1
  swap
  store

  dup
  add 2
  push 0
  store
ret

; args &V
label vector_destroy
  dup
  call vector_get_addr
  call mfree
  call mfree
ret

; args &V offset length value
label vector_fill
  copy 3
  copy 3
  copy 3
  add
  call __vector_ensure_capacity

  copy 3
  call vector_get_addr
  copy 3
  add
  ; [&V,offset,length,value,&dest]
  swap
  copy 2
  ; [&V,offset,length,&dest,value,size]
  call memset

  ; [&V,offset,length]
  add
  swap
  add 2
  swap
  store
ret

; args &V
; returns &data
label vector_get_addr
  retrieve
ret

; args &V
; returns capacity
label vector_get_capacity
  add 1
  retrieve
ret

; args &V
; returns length
label vector_get_length
  add 2
  retrieve
ret

; args &V value
label vector_push
  swap
  dup
  call vector_get_length
  add 1
  copy 1
  copy 1
  call __vector_ensure_capacity

  ; [value, &V, len+1]
  dup
  copy 2
  add 2
  swap
  store

  sub 1
  swap
  call vector_get_addr
  add
  swap
  store
ret

; args &V
; returns value
label vector_pop
  dup
  call vector_get_length
  sub 1
  copy 1
  call vector_get_addr
  copy 1
  add
  ; [&V, len-1, value]
  swap
  dup
  ; in case of out-of-bounds we don't have exceptions :( undefined behaviour, but keep length to 0 to avoid other complications
  jumpn __vector_pop_exit
    copy 2
    add 2
    copy 2
    store
  label __vector_pop_exit
  slide 2
ret

; args &V length
label vector_truncate
  swap
  add 2
  swap
  store
ret

; args &V offset length
; returns &Vslice
label vector_slice
  dup
  dup
  div 2
  add
  call vector_new
  ; [&V,offset,length,&Vslice]
  ; memcpy args: source, dest, size
  copy 3
  call vector_get_addr
  copy 3
  add
  copy 1
  call vector_get_addr
  copy 3
  call memcpy

  dup
  add 2
  copy 2
  store
  slide 3
ret

; args &Vtarget &Vsrc
label vector_concat
  copy 1
  call vector_get_length
  copy 1
  call vector_get_length
  add
  dup
  copy 3
  swap
  call __vector_ensure_capacity

  ; [&V,&Vsrc,len]
  ; memcpy args: source, dest, size
  copy 1
  dup
  call vector_get_addr
  swap
  call vector_get_length
  ; [&V,&Vsrc,len,&src,size]
  copy 4
  call vector_get_addr
  swap
  call memcpy

  slide 1
  swap
  add 2
  swap
  store
ret

; args &V offset length
; returns &Vspliced
label vector_splice
  copy 2
  call vector_get_capacity
  call vector_new
  ; [&V,offset,len,&Vspliced]
  ; memcpy args: source, dest, size
  copy 3
  call vector_get_addr
  copy 1
  call vector_get_addr
  copy 4
  call memcpy

  copy 2
  copy 2
  add
  ; [&V,offset,len,&Vspliced,start]
  dup
  copy 5
  call vector_get_addr
  add
  ; [&V,offset,len,&Vspliced,start,&src]
  copy 2
  call vector_get_addr
  copy 5
  add
  ; [&V,offset,len,&Vspliced,start,&src,&dest]
  copy 6
  call vector_get_length
  copy 3
  sub
  call memcpy
  pop
  ; [&V,offset,len,&Vspliced]

  ; set the length of &Vspliced
  copy 3
  call vector_get_length
  copy 2
  sub
  copy 1
  add 2
  swap
  store

  slide 3
ret

; args &V capacity
label __vector_ensure_capacity
  swap
  dup
  retrieve
  copy 1
  add 1
  retrieve
  ; [minCap, &V, &addr, cap]
  copy 3
  sub
  jumpn __vector_ensure_capacity_move
    slide 2
    pop
    ret
  label __vector_ensure_capacity_move
  ; [minCap, &V, &addr]
  copy 2
  dup
  div 2
  add
  call realloc
  ; [minCap, &V, &addr]
  store
  pop
ret

label lib_vector_end
