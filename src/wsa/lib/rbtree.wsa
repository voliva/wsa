include slotmap

jump lib_rbtree_end

; RED=1
; BLACK=0

valueinteger __RBTREE_MASK_RB 0x1_00000000_00000000_00000000
valueinteger __RBTREE_MASK_PARENT 0x1_00000000_00000000
valueinteger __RBTREE_MASK_LEFT 0x1_00000000
valueinteger __RBTREE_MASK_RIGHT 0x1
valueinteger __RBTREE_MASK_MOD 0x1_00000000

; returns &RB
label rbtree_new
  push 3 ; [red/black | parent | left | right, key, value]
  call slotmap_new
  ; 1st element in slotmap is a pointer to the root. 0 is nil pointer.
  dup
  dup
  call slotmap_allocate
  call slotmap_get_addr
  push 0
  store
ret

; args &RB key value
label rbtree_insert
  swap
  copy 2
  push 0
  call slotmap_get_addr
  retrieve
  jumpz rbtree_insert_empty
    ; TODO
  ret

  label rbtree_insert_empty
  copy 2
  call slotmap_allocate
  ; [&RB value key id]
  dup
  copy 4
  swap
  call slotmap_get_addr
  swap
  ; [&RB value key &node id]
  copy 4
  push 0
  call slotmap_get_addr
  swap
  store
  ; [&RB value key &node]
  dup
  push 0x00000001_00000000_00000000_00000000 ; red | nil | nil | nil
  store

  swap
  copy 1
  add 1
  swap
  store
  ; [&RB value &node]

  add 2
  swap
  store
  ; [&RB]
  pop
ret

; Got from https://en.wikipedia.org/wiki/Red%E2%80%93black_tree
; args &RB id dir
label __rbtree_rotate
  ; Change root
  copy 2
  copy 2
  call slotmap_get_addr
  ; [&RB,id,dir,&sub]
  copy 3
  copy 2
  call __rbtree_negate_dir
  copy 1
  retrieve
  swap
  div
  mod __RBTREE_MASK_MOD
  ; [&RB,id,dir,&sub,new_root_id]
  copy 1
  retrieve
  div __RBTREE_MASK_PARENT
  mod __RBTREE_MASK_MOD
  ; [&RB,id,dir,&sub,new_root_id,parent_id]
  dup
  jumpz __rbtree_rotate_tree_root
    copy 5 ; &RB
    swap
    call slotmap_get_addr
    ; [&RB,id,dir,&sub,new_root_id,&parent]
    dup
    retrieve
    copy 5 ; id
    swap
    call __rbtree_get_node_dir
    ; [&RB,id,dir,&sub,new_root_id,&parent,sub_dir]
    copy 2
    call __rbtree_set_header_param
    jump __rbtree_rotate_tree_root_end
  label __rbtree_rotate_tree_root
    pop
    copy 4 ; &RB
    push 0
    call slotmap_get_addr
    ; [&RB,id,dir,&sub,new_root_id,&root]
    copy 1
    store
    ; [&RB,id,dir,&sub,new_root_id]
  label __rbtree_rotate_tree_root_end

  ; update new_root references (new_root <-> sub <-> new_child)
  ; new_root->child[dir] = sub;
  dup
  copy 5 ; &RB
  swap
  call slotmap_get_addr
  ; [&RB,id,dir,&sub,new_root_id,&new_root]
  dup
  retrieve
  copy 4 ; dir
  div
  mod __RBTREE_MASK_MOD
  swap
  ; [&RB,id,dir,&sub,new_root_id,new_child_id,&new_root]
  dup
  copy 5 ; dir
  copy 7 ; id
  call __rbtree_set_header_param
  ; [&RB,id,dir,&sub,new_root_id,new_child_id,&new_root]
  ; new_root->parent = sub->parent
  copy 3 ; &sub
  retrieve
  div __RBTREE_MASK_PARENT
  mod __RBTREE_MASK_MOD
  push __RBTREE_MASK_PARENT
  swap
  call __rbtree_set_header_param
  ; [&RB,id,dir,&sub,new_root_id,new_child_id]
  ; sub->child[dir] = new_child_id
  dup
  copy 3 ; &sub
  swap
  copy 5 ; dir
  swap
  call __rbtree_set_header_param
  ; [&RB,id,dir,&sub,new_root_id,new_child_id]
  ; if (new_child) new_child->parent = sub;
  dup
  jumpz __rbtree_rotate_no_child
    copy 5 ; &RB
    swap
    call slotmap_get_addr
    ; [&RB,id,dir,&sub,new_root_id,&new_child]
    push __RBTREE_MASK_PARENT
    copy 5 ; id
    call __rbtree_set_header_param
    ; [&RB,id,dir,&sub,new_root_id]
    ; match other branch
    push 0
  label __rbtree_rotate_no_child
  pop
  ; [&RB,id,dir,&sub,new_root_id]
  ; sub->parent = new_root
  push __RBTREE_MASK_PARENT
  swap
  call __rbtree_set_header_param
  ; [&RB,id,dir]
  slide 2
  pop
ret

; args &header param value
label __rbtree_set_header_param
  copy 2
  retrieve
  ; [&header,param,new_value,old_header]
  ; reset current value to zero
  dup
  copy 3
  div
  mod __RBTREE_MASK_MOD
  copy 3
  mul
  sub
  ; [&header,param,new_value,header]
  ; add new value
  swap
  copy 2
  mul
  add
  ; [&header,param,new_header]
  slide 1
  store
ret

; args dir
; returns left/right mask
label __rbtree_negate_dir
  sub __RBTREE_MASK_LEFT
  jumpz __rbtree_negate_dir_left
    push __RBTREE_MASK_LEFT
    ret
  label __rbtree_negate_dir_left
  push __RBTREE_MASK_RIGHT
ret

; args node_id parent_header
; returns left/right mask
label __rbtree_get_node_dir
  ; swap
  ; dup
  ; copy 2
  ; call slotmap_get_addr
  ; retrieve
  ; div __RBTREE_MASK_PARENT
  ; mod __RBTREE_MASK_MOD
  ; ; [node_id,&RB,parent_id]
  ; call slotmap_get_addr
  ; retrieve
  div __RBTREE_MASK_LEFT
  mod __RBTREE_MASK_MOD
  sub
  jumpz __rbtree_get_node_dir_left
    push __RBTREE_MASK_RIGHT
    ret
  label __rbtree_get_node_dir_left
  push __RBTREE_MASK_LEFT
ret

; args &RB key
; returns [value,found]
label rbtree_get
  copy 1
  push 0
  call slotmap_get_addr
  retrieve
  call __rbtree_get
ret

; args &RB key id
; returns [value,found]
label __rbtree_get
  dup
  jumpz __rbtree_get_not_found
    copy 2
    swap
    call slotmap_get_addr
    dup
    add 1
    retrieve
    ; [&RB,key,&node,node.key]
    copy 2
    sub
    dup
    jumpz __rbtree_get_found
      jumpn __rbtree_get_bigger
        ; smaller
        push __RBTREE_MASK_LEFT
        jump __rbtree_get_continue
      label __rbtree_get_bigger
        push __RBTREE_MASK_RIGHT
      label __rbtree_get_continue
      ; [&RB,key,&node,mask]
      swap
      retrieve
      swap
      div
      mod __RBTREE_MASK_MOD
      call __rbtree_get
      ret
    label __rbtree_get_found
    pop
    ; [&RB,key,&node]
    add 2
    retrieve
    slide 2
    push 1
    ret
  label __rbtree_get_not_found
  slide 2
  push 0
ret

; args &RB key
label rbtree_remove
  ; TODO
ret

label lib_rbtree_end